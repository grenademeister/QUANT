"""
PyTorch implementation of MA model
only for test purpose
this code is generated by LLM
"""

import torch
import torch.nn as nn
import torch.optim as optim
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


class MAModelTorch(nn.Module):
    def __init__(self, q: int):
        super().__init__()
        self.q = q
        self.theta = nn.Parameter(torch.zeros(q))

    def forward(self, x: torch.Tensor):
        n = len(x)
        eps = torch.zeros(n, device=x.device)
        for t in range(n):
            k = min(t, self.q)
            eps[t] = x[t] - torch.dot(self.theta[:k], eps[t - k : t].flip(0))
        return eps

    def predict(self, x: torch.Tensor, steps: int, mu: float):
        """Predict future values assuming zero future residuals."""
        eps = self.forward(x).detach()
        recent_eps = eps[-self.q :].tolist()

        preds = []
        for _ in range(steps):
            k = min(len(recent_eps), self.q)
            y_hat = torch.dot(
                self.theta[:k], torch.tensor(recent_eps[-k:][::-1], device=x.device)
            )
            preds.append((y_hat + mu).item())
            recent_eps.append(0.0)  # Future eps = 0

        return np.array(preds)


def test_ma_model_torch(
    ts: pd.Series, q: int = 2, lr: float = 1e-2, epochs: int = 1000, steps: int = 10
):
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    x_np = ts.to_numpy(dtype=np.float32)
    mu = x_np.mean()
    x_centered = x_np - mu
    x = torch.tensor(x_centered, dtype=torch.float32, device=device)

    model = MAModelTorch(q).to(device)
    optimizer = optim.Adam(model.parameters(), lr=lr)

    losses = []
    for epoch in range(epochs):
        optimizer.zero_grad()
        eps = model(x)
        loss = 0.5 * torch.mean(eps**2)
        loss.backward()
        optimizer.step()

        losses.append(loss.item())
        if epoch % 100 == 0:
            print(f"[{epoch}] Loss = {loss.item():.6f}")

    print("Final Î¸:", model.theta.data.cpu().numpy())

    # Plot loss curve
    plt.figure(figsize=(10, 4))
    plt.plot(losses)
    plt.title("MA Model Loss")
    plt.xlabel("Epoch")
    plt.ylabel("Loss")
    plt.grid()
    plt.tight_layout()
    plt.show()

    # Forecast
    preds = model.predict(x, steps, mu)
    print(f"Preds: {preds}")

    # Plot forecast
    plt.figure(figsize=(10, 4))
    plt.plot(np.arange(len(ts)), ts, label="Train Series")
    plt.plot(np.arange(len(ts), len(ts) + steps), preds, label="Forecast", marker="o")
    plt.title("MA Model Forecast")
    plt.xlabel("Time")
    plt.ylabel("Value")
    plt.legend()
    plt.grid()
    plt.tight_layout()
    plt.show()

    return model, mu


# Simulate and run
if __name__ == "__main__":
    np.random.seed(0)
    n = 300
    ar_coef = np.array([0.6, -0.3])
    ma_coef = np.array([0.5, 0.4])
    noise = np.random.randn(n + 100)
    x = np.zeros(n + 100)

    for t in range(2, len(x)):
        ar_part = np.dot(ar_coef, x[t - 2 : t][::-1])
        ma_part = np.dot(ma_coef, noise[t - 2 : t][::-1])
        x[t] = ar_part + ma_part + noise[t]

    x = np.cumsum(x[100:])
    ts = pd.Series(x)

    model, mu = test_ma_model_torch(ts, q=2, lr=1e-2, epochs=400, steps=10)
